[
  {
    "slug": "portfolio-website",
    "title": "Portfolio Website with Markdown Content System",
    "description": "A vanilla JavaScript portfolio with custom markdown-based content management, built the hard way because I refused to learn Jekyll.",
    "tags": [
      "css",
      "js",
      "html",
      "markdown",
      "github",
      "node"
    ],
    "demo": "https://tianpretorius.github.io",
    "github": "https://github.com/tian102/tianpretorius.github.io",
    "image": "https://images.unsplash.com/photo-1487017159836-4e23ece2e4cf?w=1200&h=630&fit=crop",
    "coverImage": "https://images.unsplash.com/photo-1487017159836-4e23ece2e4cf?w=1200&h=630&fit=crop",
    "date": "2024-10-09",
    "content": "\r\n# Portfolio Website with Markdown Content System\r\n\r\nA custom-built portfolio website that takes markdown files and turns them into a dynamic, navigable site—all without frameworks, without a backend, and definitely without using the perfectly good tools that already existed.\r\n\r\n## 🎯 Project Overview\r\n\r\nThis portfolio was born from necessity (needing a place to showcase my work) and fueled by stubbornness (refusing to do things the easy way).\r\n\r\nGitHub Pages offers a fantastic tool called Jekyll that makes working with markdown files incredibly straightforward. It's mature, well-documented, and used by thousands of developers.\r\n\r\nI chose not to use it.\r\n\r\nWhy? Because learning \"just another tool\" felt like an investment of time I wasn't willing to make. Instead, I decided to reinvent the wheel—spending 10+ hours building a custom system to automate what I could have done with Jekyll in an afternoon.\r\n\r\nClassic developer move, right?\r\n\r\nBut in the process, I learned a lot, built something that's truly mine, and ended up with a portfolio system that works exactly the way I want it to.\r\n\r\n## ✨ Key Features\r\n\r\n- **Markdown-Based Content Management**: Write blog posts and project descriptions in markdown, complete with frontmatter for metadata\r\n- **Automated Build System**: Node.js script that parses markdown files and generates JSON data at build time\r\n- **Modular Directory Structure**: Each post lives in its own directory with dedicated assets folder for images and resources\r\n- **Client-Side Routing**: Dynamic navigation using the History API, no page reloads needed\r\n- **Zero Backend Dependencies**: Everything is statically generated and served, keeping hosting costs at exactly $0\r\n- **Responsive Design**: Mobile-first approach with smooth animations and transitions\r\n\r\n## 🛠️ Technology Stack\r\n\r\n### Frontend\r\n- **Vanilla JavaScript**: No frameworks—just pure JS for maximum control and minimal bundle size\r\n- **HTML5 & CSS3**: Semantic markup with modern CSS features (custom properties, grid, flexbox)\r\n- **marked.js**: Markdown parsing library for converting content to HTML\r\n\r\n### Content Management\r\n- **Markdown with Frontmatter**: Write content in markdown files with YAML metadata\r\n- **Modular Structure**: Each post in its own directory (`content/blog/posts/post-name/index.md`)\r\n- **Asset Organization**: Images and resources stored alongside their content in `assets/` subdirectories\r\n\r\n### Build System\r\n- **Node.js Script**: Custom build pipeline that:\r\n  - Scans content directories for markdown files\r\n  - Parses frontmatter and content\r\n  - Generates structured JSON data files\r\n  - Processes image paths and metadata\r\n- **GitHub Actions**: Automated builds on push that regenerate content JSON\r\n\r\n### Hosting & Deployment\r\n- **GitHub Pages**: Free static hosting with custom domain support\r\n- **Git-Based Workflow**: Push to main branch triggers automatic deployment\r\n\r\n## 🏗️ Architecture & Design Decisions\r\n\r\n### Why Vanilla JavaScript Over Frameworks?\r\n\r\nFor a portfolio site, frameworks felt like overkill. The performance overhead, build complexity, and learning curve didn't justify the benefits. With vanilla JS, I got:\r\n- ~50KB total JavaScript (unminified)\r\n- Sub-100ms page transitions\r\n- Complete control over every interaction\r\n- No build step for the frontend (just for content)\r\n\r\n### The Jekyll Stubbornness Story\r\n\r\nGitHub Pages has built-in Jekyll support. It's designed for exactly this use case—turning markdown files into websites. It handles frontmatter, templating, and asset management automatically.\r\n\r\nBut I didn't want to learn Ruby. I didn't want to configure another tool. I didn't want to deal with Liquid templates.\r\n\r\nSo instead, I built my own system in Node.js that:\r\n1. Recursively scans content directories\r\n2. Reads markdown files and parses frontmatter\r\n3. Extracts metadata (title, date, tags, etc.)\r\n4. Generates clean JSON data structures\r\n5. Handles asset paths and images\r\n\r\nWas this necessary? Absolutely not.\r\n\r\nDid it take longer than learning Jekyll? Probably.\r\n\r\nDo I regret it? Not really. I learned a ton about file systems, markdown parsing, and build automation. Plus, I now have a system that works exactly how I want it to, with no magic happening behind the scenes.\r\n\r\n### Modular Content Structure\r\n\r\nOne thing I did get right: the directory structure. Each blog post and project lives in its own folder:\r\n\r\n```\r\ncontent/\r\n├── blog/\r\n│   └── posts/\r\n│       └── my-post/\r\n│           ├── index.md\r\n│           └── assets/\r\n│               └── image.jpg\r\n└── projects/\r\n    └── posts/\r\n        └── my-project/\r\n            ├── index.md\r\n            └── assets/\r\n                └── screenshot.png\r\n```\r\n\r\nThis keeps content organized, makes assets easy to find, and means I can move posts around without breaking image paths.\r\n\r\n### Build Time vs Runtime\r\n\r\nI made a key decision early on: process content at build time, not runtime.\r\n\r\nInstead of fetching markdown files and parsing them in the browser, the build script pre-processes everything into JSON. This means:\r\n- Faster page loads (no parsing overhead)\r\n- Better SEO (content is available immediately)\r\n- Simpler client-side code\r\n- Clear separation between content and presentation\r\n\r\nThe trade-off? I have to run `npm run build` every time I add or update content. But with GitHub Actions, that's automated anyway.\r\n\r\n## 📊 Results & Outcomes\r\n\r\n### Performance\r\n- **JavaScript Bundle**: ~50KB unminified (could be smaller with minification)\r\n- **Page Load Time**: Sub-second for initial load\r\n- **Navigation Speed**: <100ms transitions between pages\r\n- **No Backend**: Zero server costs, no database overhead\r\n\r\n### Developer Experience\r\n- **Content Workflow**: Write markdown → Push to GitHub → Automatic build and deploy\r\n- **Easy Updates**: Just edit a markdown file, no need to touch code\r\n- **Asset Management**: Images live next to content, no path confusion\r\n- **Version Control**: Everything in git means full history and easy rollbacks\r\n\r\n### Learning Outcomes\r\n- **File System Operations**: Deep dive into Node.js fs module and recursive directory scanning\r\n- **Markdown Parsing**: Understanding frontmatter, AST parsing, and content extraction\r\n- **Build Automation**: Creating custom build pipelines and CI/CD integration\r\n- **History API**: Client-side routing without frameworks\r\n- **The Value of Existing Tools**: Sometimes the wheel doesn't need reinventing (but it's fun anyway)\r\n\r\n## 🤔 Challenges & Lessons Learned\r\n\r\n### The Jekyll Realization\r\n\r\nAbout halfway through building my custom system, I realized Jekyll would have solved 90% of my problems out of the box. But by then, I was committed. And honestly? I learned more doing it the hard way.\r\n\r\nWould I recommend this approach to others? Probably not. But if you're the stubborn type who likes to understand every piece of the puzzle, building your own system is incredibly educational.\r\n\r\n### GitHub Pages Quirks\r\n\r\nGitHub Pages is great, but it has its peculiarities:\r\n- Deployment can be finicky if you don't understand the build process\r\n- Custom domains require specific DNS configuration\r\n- There's a learning curve to the Actions workflow\r\n- You're limited to static content (which was actually a good constraint)\r\n\r\n### The 10-Hour Automation Rule\r\n\r\nThere's a developer joke: \"I spent 10 hours automating a task that takes 2 minutes to do manually.\"\r\n\r\nThat's basically what I did here. Jekyll would have been the 2-minute solution. My custom build system was the 10-hour one.\r\n\r\nBut here's the thing: I don't regret it. Those 10 hours taught me things I wouldn't have learned otherwise. And now I have a portfolio that's uniquely mine.\r\n\r\n## 🚀 Future Improvements\r\n\r\n- **Search Functionality**: Add client-side search across blog posts and projects\r\n- **Tag Filtering**: Filter content by technology tags\r\n- **RSS Feed**: Generate an RSS feed for the blog\r\n- **Dark Mode**: Add theme toggle for dark mode support\r\n- **Performance Optimization**: Minify and bundle JavaScript\r\n- **Progressive Web App**: Add service worker for offline support\r\n\r\n## 💡 Key Takeaways\r\n\r\n1. **Constraints Drive Creativity**: Having no budget forced me to find free solutions and build creatively\r\n2. **Stubbornness Has Its Place**: Sometimes doing things the hard way teaches you more than the easy way\r\n3. **Ownership Matters**: Building my own system means I understand every piece of it\r\n4. **But Also**: Existing tools exist for a reason—don't always reinvent the wheel (even though I did)\r\n5. **Build What You Need**: This portfolio isn't perfect, but it's mine and it works\r\n\r\n---\r\n\r\n*Built with stubbornness, vanilla JavaScript, and way more custom code than was strictly necessary.*\r\n",
    "assetsPath": "",
    "projectPath": "content/projects/posts/portfolio-website/"
  },
  {
    "slug": "saas-platform",
    "title": "SaaS Platform",
    "description": "A comprehensive SaaS platform with user management, billing, and analytics dashboard built for scalability.",
    "tags": [
      "saas",
      "react",
      "node",
      "typescript",
      "stripe"
    ],
    "demo": "https://demo.example.com",
    "github": "https://github.com/tianpretorius/saas-platform",
    "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800",
    "coverImage": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800",
    "date": "2024-03-15",
    "content": "\r\n# SaaS Platform\r\n\r\n![Cover Image](https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800)\r\n\r\nA full-stack SaaS application designed to handle multi-tenant architecture with robust user management and subscription billing.\r\n\r\n## Key Features\r\n\r\n- **Multi-tenant Architecture**: Secure data isolation per organization\r\n- **Subscription Billing**: Integrated with Stripe for recurring payments\r\n- **Analytics Dashboard**: Real-time metrics and insights\r\n- **Role-based Access Control**: Granular permissions management\r\n- **REST API**: Well-documented API for third-party integrations\r\n\r\n## Technology Stack\r\n\r\n- **Frontend**: React, TypeScript, Tailwind CSS\r\n- **Backend**: Node.js, Express, PostgreSQL\r\n- **Infrastructure**: Docker, AWS, Redis\r\n- **Payment**: Stripe Integration\r\n- **Auth**: JWT with refresh tokens\r\n\r\n## Challenges Overcome\r\n\r\nOne of the biggest challenges was implementing efficient multi-tenancy while maintaining data security and query performance. I solved this using a hybrid approach with schema-per-tenant for larger clients and shared schema with row-level security for smaller accounts.\r\n\r\n## Results\r\n\r\n- Handles 10,000+ active users\r\n- 99.9% uptime SLA\r\n- Sub-200ms API response times\r\n- Successfully processing $100K+ MRR\r\n",
    "assetsPath": "content/projects/posts/saas-platform/assets/",
    "projectPath": "content/projects/posts/saas-platform/"
  },
  {
    "slug": "real-time-dashboard",
    "title": "Real-Time Analytics Dashboard",
    "description": "High-performance dashboard displaying real-time metrics with WebSocket connections and interactive visualizations.",
    "tags": [
      "react",
      "websocket",
      "chartjs",
      "python",
      "redis"
    ],
    "demo": "https://dashboard.example.com",
    "github": "https://github.com/tianpretorius/analytics-dashboard",
    "image": "content/projects/posts/real-time-dashboard/cover.jpg",
    "coverImage": "content/projects/posts/real-time-dashboard/cover.jpg",
    "date": "2024-01-20",
    "content": "\r\n# Real-Time Analytics Dashboard\r\n\r\n![Cover Image](cover.jpg)\r\n\r\nA powerful real-time analytics dashboard that processes and visualizes thousands of events per second with minimal latency.\r\n\r\n## Key Features\r\n\r\n- **Real-Time Updates**: WebSocket-based live data streaming\r\n- **Interactive Charts**: Customizable visualizations with Chart.js\r\n- **Data Aggregation**: Efficient time-series data processing\r\n- **Responsive Design**: Works seamlessly on all devices\r\n- **Export Capabilities**: Download reports in CSV/PDF formats\r\n\r\n## Technology Stack\r\n\r\n- **Frontend**: React, Redux, Chart.js, Socket.io\r\n- **Backend**: Python, FastAPI, Redis, PostgreSQL\r\n- **Real-time**: WebSocket connections\r\n- **Caching**: Redis for fast data retrieval\r\n\r\n## Performance Optimizations\r\n\r\nImplemented several optimization strategies:\r\n- Data aggregation at ingestion time\r\n- In-memory caching with Redis\r\n- Efficient WebSocket connection pooling\r\n- Debounced chart re-rendering\r\n- Virtual scrolling for large datasets\r\n\r\n## Impact\r\n\r\nThe dashboard reduced decision-making time by 60% by providing instant insights into critical business metrics. It now serves as the central monitoring tool for the entire operations team.\r\n",
    "assetsPath": "content/projects/posts/real-time-dashboard/assets/",
    "projectPath": "content/projects/posts/real-time-dashboard/"
  },
  {
    "slug": "mobile-fitness-app",
    "title": "Mobile Fitness Tracker",
    "description": "Cross-platform mobile app for workout tracking, meal planning, and progress analytics with offline-first capabilities.",
    "tags": [
      "react-native",
      "mobile",
      "firebase",
      "typescript"
    ],
    "demo": "https://apps.apple.com/app/fitness-tracker",
    "github": "",
    "image": "https://images.unsplash.com/photo-1476480862126-209bfaa8edc8?w=800",
    "coverImage": "https://images.unsplash.com/photo-1476480862126-209bfaa8edc8?w=800",
    "date": "2023-11-10",
    "content": "\r\n# Mobile Fitness Tracker\r\n\r\n![Cover Image](https://images.unsplash.com/photo-1476480862126-209bfaa8edc8?w=800)\r\n\r\nA comprehensive fitness tracking application built with React Native, featuring workout logging, nutrition tracking, and detailed progress analytics.\r\n\r\n## Key Features\r\n\r\n- **Workout Tracking**: Log exercises with sets, reps, and weights\r\n- **Meal Planning**: Track calories and macronutrients\r\n- **Progress Photos**: Visual progress tracking over time\r\n- **Offline Mode**: Full functionality without internet connection\r\n- **Social Features**: Share achievements with friends\r\n- **Custom Workouts**: Create and save personalized routines\r\n\r\n## Technology Stack\r\n\r\n- **Framework**: React Native (iOS & Android)\r\n- **State Management**: Redux Toolkit\r\n- **Backend**: Firebase (Auth, Firestore, Storage)\r\n- **Local Storage**: WatermelonDB for offline-first architecture\r\n- **Charts**: Victory Native for data visualizations\r\n\r\n## Technical Highlights\r\n\r\n### Offline-First Architecture\r\n\r\nImplemented a robust offline-first system using WatermelonDB that syncs seamlessly with Firebase when connectivity is restored. This ensures users can log workouts anywhere, anytime.\r\n\r\n### Performance\r\n\r\n- Optimized images with lazy loading and caching\r\n- Implemented memoization for expensive calculations\r\n- Used FlatList optimization for smooth scrolling\r\n- Reduced app size by 40% through code splitting\r\n\r\n## User Reception\r\n\r\n- 4.8★ rating on App Store\r\n- 10,000+ downloads in first 3 months\r\n- Featured in \"New Apps We Love\"\r\n- 70% daily active user retention\r\n",
    "assetsPath": "content/projects/posts/mobile-fitness-app/assets/",
    "projectPath": "content/projects/posts/mobile-fitness-app/"
  },
  {
    "slug": "api-gateway",
    "title": "Microservices API Gateway",
    "description": "High-performance API gateway handling authentication, rate limiting, and request routing for microservices architecture.",
    "tags": [
      "golang",
      "microservices",
      "docker",
      "kubernetes",
      "api"
    ],
    "demo": "",
    "github": "https://github.com/tianpretorius/api-gateway",
    "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=500&fit=crop",
    "coverImage": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=500&fit=crop",
    "date": "2023-09-05",
    "content": "\r\n# Microservices API Gateway\r\n\r\nA custom-built API gateway in Go designed to handle high-throughput traffic with intelligent routing, caching, and security features.\r\n\r\n## Key Features\r\n\r\n- **Intelligent Routing**: Dynamic service discovery and load balancing\r\n- **Authentication**: JWT validation with token refresh\r\n- **Rate Limiting**: Configurable per-endpoint rate limits\r\n- **Request/Response Caching**: Redis-based caching layer\r\n- **Circuit Breaker**: Automatic failover and retry logic\r\n- **Monitoring**: Built-in metrics and distributed tracing\r\n\r\n## Technology Stack\r\n\r\n- **Language**: Go (Golang)\r\n- **Cache**: Redis\r\n- **Service Mesh**: Kubernetes with Istio\r\n- **Monitoring**: Prometheus & Grafana\r\n- **Containerization**: Docker\r\n\r\n## Architecture Decisions\r\n\r\n### Why Go?\r\n\r\nChose Go for its exceptional performance, built-in concurrency, and low memory footprint. The gateway handles 50,000+ requests per second on modest hardware.\r\n\r\n### Rate Limiting Strategy\r\n\r\nImplemented a distributed rate limiter using Redis and the token bucket algorithm, ensuring fair resource allocation across all microservices.\r\n\r\n## Performance Metrics\r\n\r\n- **Throughput**: 50,000+ RPS\r\n- **Latency**: p99 < 10ms\r\n- **Uptime**: 99.99%\r\n- **Memory Usage**: < 100MB under load\r\n\r\n## Security Features\r\n\r\n- TLS termination\r\n- SQL injection prevention\r\n- CORS configuration\r\n- Request validation and sanitization\r\n- IP whitelisting/blacklisting\r\n\r\nThe gateway serves as the single entry point for all external API requests, providing a secure and performant interface to our microservices ecosystem.\r\n",
    "assetsPath": "content/projects/posts/api-gateway/assets/",
    "projectPath": "content/projects/posts/api-gateway/"
  }
]