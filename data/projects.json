[
  {
    "slug": "eggsplorer-platform",
    "title": "Eggsplorer - Interactive Hunt Platform",
    "description": "A web-based platform for creating and running digital scavenger hunts, Easter egg hunts, and trivia challenges with real-time tracking and leaderboards.",
    "tags": [
      "php",
      "mysql",
      "javascript",
      "bootstrap",
      "ajax",
      "web-development"
    ],
    "demo": "",
    "github": "https://github.com/tian102/Eggsplorer",
    "image": "content/projects/posts/eggsplorer-platform/./assets/Eggsplorer.png",
    "coverImage": "content/projects/posts/eggsplorer-platform/./assets/Eggsplorer.png",
    "date": "2025-10-10",
    "content": "\r\n# Eggsplorer - Interactive Hunt Platform\r\n\r\nA full-stack web application that transforms traditional scavenger hunts into interactive digital experiences. Built for Easter events, it combines online challenges with physical hunting through a two-phase system: solve the puzzle, find the egg, claim your points.\r\n\r\n![Eggsplorer Banner](./assets/Eggsplorer.png)\r\n\r\n## The Story Behind It\r\n\r\nThis started as a \"wouldn't it be fun if...\" idea three weeks before Easter last year. I was hosting and wanted to make the traditional egg hunt more engaging. The first version was rough—buggy, barely functional, held together with duct tape and hope—but people loved it.\r\n\r\nThis year, I rebuilt it properly. Fixed the bugs, overhauled the UI, added all the features I wished existed last time, and turned it into a real platform that could handle any type of hunt event.\r\n\r\nIt's definitely over-engineered for a family Easter party, but that's kind of the point. Sometimes you build things not because they're necessary, but because they're interesting.\r\n\r\n## How It Works\r\n\r\nThe concept is simple but effective:\r\n\r\n### Two-Phase Challenge System\r\n\r\n**Phase 1: The Mental Game**  \r\nParticipants solve digital challenges (trivia questions, riddles, math problems, whatever you want) on their phones or computers. Get it right, unlock the location clue.\r\n\r\n**Phase 2: The Physical Hunt**  \r\nOnce solved, a 10-minute timer starts. They have to find the physical \"egg\" (could be a QR code, object, location—anything) and claim it before time runs out. No claiming, no points.\r\n\r\nThis approach:\r\n- Prevents the fastest runner from dominating everything\r\n- Adds tension with the timer countdown\r\n- Works for all ages and skill levels\r\n- Can be played indoors if weather doesn't cooperate\r\n- Creates little moments of excitement (\"I got it!\" followed by frantic searching)\r\n\r\n### Sequential Tasks\r\n\r\nTasks unlock in sequence—you can't skip ahead to easier ones. This keeps everyone progressing at their own pace and prevents one person from hogging all the eggs.\r\n\r\n### Persistent Hints\r\n\r\nNeed help? Reveal a hint. It'll cost you a few points, but once revealed, it stays visible even if you refresh the page. No accidental hint loss like in version 1.\r\n\r\n### Live Leaderboards\r\n\r\nPoints update in real-time (well, every 30 seconds) so everyone can see the competition. Watching people's reactions when they climb the board after claiming an egg never gets old.\r\n\r\n## Key Features\r\n\r\n### For Participants\r\n- **Clean, Mobile-Friendly Interface**: Works smoothly on phones, tablets, and computers. Built with Bootstrap so it looks decent everywhere.\r\n- **Multiple Event Types**: Easter egg hunts, treasure hunts, scavenger hunts, trivia challenges—same platform, different themes.\r\n- **Progressive Task System**: Tasks unlock in order, each with its own points value and difficulty.\r\n- **Timer-Based Egg Claiming**: 10-minute countdown creates urgency without being overwhelming.\r\n- **Hint System**: Get stuck? Reveal hints for a small point penalty. They persist so you won't lose them.\r\n- **Real-Time Leaderboard**: See your ranking update as you and others claim eggs.\r\n- **Progress Tracking**: Visual indicators show which tasks you've completed and which eggs you've claimed.\r\n- **Automatic Task Reopening**: Timer expired? Task reopens automatically so you can try again.\r\n\r\n![User Dashboard](./assets/4.%20logged_in_welcome_page.jpeg)\r\n*Personalized dashboard showing active events and leaderboard*\r\n\r\n### For Organizers (Admin Panel)\r\n- **Event Management**: Create events with custom names, descriptions, start/end times, and types.\r\n- **Task Builder**: Add tasks with questions, answers, point values, and sequence ordering.\r\n- **Hint Configuration**: Set up hints with time delays and point costs.\r\n- **User Management**: See who's registered, promote admins, monitor activity.\r\n- **Live Monitoring**: Watch event progress in real-time, see who's stuck, who's winning.\r\n- **JSON Templates**: Export entire events as JSON files, edit them, import for quick setup.\r\n- **Analytics Dashboard**: View completion rates, engagement metrics, and task difficulty analysis.\r\n- **Activity Logs**: Complete audit trail of all user actions for debugging and oversight.\r\n\r\n![Admin Dashboard](./assets/8.%20admin_dashboard.jpeg)\r\n*Admin overview with key metrics and system status*\r\n\r\n## Technical Overview\r\n\r\n### The Stack\r\n\r\nBuilt with technologies I already knew—no time to learn frameworks when Easter's three weeks away:\r\n\r\n- **PHP 8**: Server-side logic and session management\r\n- **MySQL**: Database with proper relational structure\r\n- **JavaScript (Vanilla)**: AJAX interactions, timers, dynamic UI updates\r\n- **Bootstrap 5**: Responsive UI framework for consistent styling\r\n- **Chart.js**: Analytics visualizations for the admin dashboard\r\n\r\n### Why These Choices?\r\n\r\n**PHP/MySQL**: I knew them. XAMPP makes local hosting trivial. No server costs. Works great for small-to-medium events (tested with 100+ concurrent users without issues).\r\n\r\n**No Framework**: For something this size, frameworks felt like overkill. Vanilla PHP with good organization is perfectly fine. Plus, I learned more by building the structure myself.\r\n\r\n**Bootstrap**: I'm not a designer. Bootstrap makes things look good without requiring design skills. It's responsive out of the box, which matters when everyone's on their phones.\r\n\r\n**Vanilla JavaScript**: The interactivity isn't complex enough to justify React/Vue. Event listeners and fetch calls handle everything needed.\r\n\r\n## Architecture Highlights\r\n\r\n### Database Design\r\n\r\nThe schema tracks everything needed for a smooth experience:\r\n\r\n- **users**: Login credentials, admin status\r\n- **events**: Event details, start/end times, types\r\n- **tasks**: Questions, answers, points, sequence order\r\n- **hints**: Hint text, time delays, point costs\r\n- **event_participants**: Who's in which events, their total points\r\n- **user_tasks**: Task completion status, timestamps, egg claimed status\r\n- **user_hints**: Which hints have been revealed to whom\r\n- **activity_logs**: Full audit trail of all actions\r\n\r\nForeign keys enforce data integrity. Indexes on frequently-joined columns keep queries fast (leaderboard queries run in ~15ms even with lots of participants).\r\n\r\n### State Management\r\n\r\nThe server is the single source of truth for everything that matters:\r\n\r\n**Timer Logic**: When you complete a task, we store the timestamp. When you try to claim an egg, we calculate how much time has actually passed server-side. No client-side manipulation possible.\r\n\r\n**Points**: All point calculations happen on the server. AJAX calls send the action, server validates and responds with updated totals.\r\n\r\n**Progress**: Task completion, egg claiming, hint reveals—all tracked in the database and validated on every action.\r\n\r\nThe client just displays what the server tells it. Keeps things honest.\r\n\r\n### AJAX Layer\r\n\r\nEverything that can be async, is:\r\n\r\n- Submit answers without page reload\r\n- Reveal hints instantly\r\n- Claim eggs with feedback\r\n- Update leaderboards every 30 seconds\r\n- Leave events gracefully\r\n\r\nEach AJAX endpoint validates the session, checks permissions, performs the action, and returns structured JSON. Clean separation of concerns.\r\n\r\n### Security\r\n\r\nNot trying to protect nuclear codes, but built in common-sense security:\r\n\r\n- **SQL Injection Prevention**: Parameterized queries everywhere using PDO\r\n- **CSRF Protection**: Tokens on all forms and AJAX requests\r\n- **XSS Prevention**: All user input sanitized before display\r\n- **Password Security**: bcrypt hashing, never stored plaintext\r\n- **Session Security**: HTTP-only cookies, session regeneration, timeouts\r\n- **Admin Protection**: All admin routes check permissions\r\n\r\nGood enough for a family Easter party and then some.\r\n\r\n## Development Journey\r\n\r\n### Version 1 (Last Year)\r\n\r\nBuilt in about two weeks. Features:\r\n- Basic login/registration\r\n- Task display and answer submission\r\n- Egg hunt timer (that worked... mostly)\r\n- Point tracking (sometimes)\r\n- Minimal UI (functional but ugly)\r\n\r\nProblems:\r\n- Timer could be cheated by refreshing\r\n- No admin panel (used phpMyAdmin during event)\r\n- Concurrent claims could cause issues\r\n- Leaderboard rarely updated correctly\r\n- UI was rough on mobile\r\n- I spent the event debugging instead of participating\r\n\r\nResult: Everyone had fun anyway. Got great feedback on what to improve.\r\n\r\n### Version 2 (This Year)\r\n\r\nComplete rebuild over a few months. Added:\r\n- Server-authoritative timers (no more cheating)\r\n- Full-featured admin panel\r\n- Proper AJAX architecture\r\n- Persistent hints\r\n- Clean, responsive UI\r\n- JSON template system\r\n- Analytics dashboard\r\n- Activity logging\r\n- Database optimizations\r\n\r\nResult: Actually works reliably. Can participate in events instead of debugging. Looks professional enough that I'm not embarrassed to show people.\r\n\r\n### What I Learned\r\n\r\n**Start Simple**: Version 1 proved the concept. Version 2 made it good. If I'd tried to build version 2 from scratch, I'd still be working on it.\r\n\r\n**User Feedback Matters**: Every complaint from last year became a feature this year. Persistent hints, automatic task reopening, better mobile UI—all from user feedback.\r\n\r\n**Good Enough Is Good Enough**: It's not the most elegant code. It's not using cutting-edge tech. But it works, it's maintainable, and people enjoy using it. That's what matters.\r\n\r\n**Overengineering Can Be Fun**: Yes, I over-engineered an Easter egg hunt. No regrets. The process of building taught me things, and now I have a reusable platform for any hunt-style event.\r\n\r\n## Screenshots\r\n\r\n### Event Participation Flow\r\n\r\n<table>\r\n  <tr>\r\n    <td width=\"33%\">\r\n      <img src=\"./assets/5. egg_hunt.jpeg\" alt=\"Event View\">\r\n      <p align=\"center\"><em>Event task list and progress tracking</em></p>\r\n    </td>\r\n    <td width=\"33%\">\r\n      <img src=\"./assets/6. egg_search.jpg\" alt=\"Egg Hunt\">\r\n      <p align=\"center\"><em>Egg hunt phase with 10-minute timer</em></p>\r\n    </td>\r\n    <td width=\"33%\">\r\n      <img src=\"./assets/7. egg_found.jpeg\" alt=\"Success\">\r\n      <p align=\"center\"><em>Successful egg claim confirmation</em></p>\r\n    </td>\r\n  </tr>\r\n</table>\r\n\r\n### Admin Panel\r\n\r\n<table>\r\n  <tr>\r\n    <td width=\"50%\">\r\n      <img src=\"./assets/9. admin_manage_events.jpeg\" alt=\"Manage Events\">\r\n      <p align=\"center\"><em>Event management interface</em></p>\r\n    </td>\r\n    <td width=\"50%\">\r\n      <img src=\"./assets/11. admin_analytics_dashboard.jpeg\" alt=\"Analytics\">\r\n      <p align=\"center\"><em>Analytics dashboard with Chart.js visualizations</em></p>\r\n    </td>\r\n  </tr>\r\n</table>\r\n\r\n## Cool Features I'm Proud Of\r\n\r\n### JSON Template System\r\n\r\nYou can export an entire event (tasks, hints, settings) as a JSON file, edit it, and import it to create a new event. Makes testing fast and lets you share event templates.\r\n\r\n```json\r\n{\r\n  \"event\": {\r\n    \"name\": \"Easter Hunt 2025\",\r\n    \"event_type\": \"Egg Hunt\",\r\n    \"start_datetime\": \"2025-04-20 10:00:00\"\r\n  },\r\n  \"tasks\": [\r\n    {\r\n      \"title\": \"Find the Golden Egg\",\r\n      \"expected_answer\": \"golden\",\r\n      \"points\": 100,\r\n      \"hints\": [\r\n        {\"hint_text\": \"Check the garden\"}\r\n      ]\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nThe template handler validates everything, uses database transactions for atomicity, and provides clear error messages if something's wrong.\r\n\r\n### Automatic Task Reopening\r\n\r\nTimer expired before you found the egg? The task automatically reopens via AJAX. You get a notification and can try again. No manual intervention needed.\r\n\r\n### Persistent Hint Display\r\n\r\nOnce a hint is revealed, it stays visible. The database tracks which hints you've seen, so refreshing won't lose them. Small detail, huge UX improvement.\r\n\r\n### Real-Time-ish Updates\r\n\r\nLeaderboards update every 30 seconds via AJAX polling. Not true real-time (that would need WebSockets), but feels responsive enough and keeps server load reasonable.\r\n\r\n### Admin Analytics\r\n\r\nThe analytics dashboard shows:\r\n- Event completion rates\r\n- Average time per task\r\n- Hint usage patterns (indicates task difficulty)\r\n- Participant engagement over time\r\n\r\nBuilt with Chart.js, looks professional, actually useful for tuning event difficulty.\r\n\r\n## Challenges Overcome\r\n\r\n### The Timer Problem\r\n\r\n**Challenge**: Client-side timers can be manipulated (refresh page, change system clock).\r\n\r\n**Solution**: Store task completion timestamp in database. Calculate elapsed time server-side on every page load and when claiming eggs. JavaScript timer is just for display.\r\n\r\n### Concurrent Claims\r\n\r\n**Challenge**: Multiple people claiming same egg simultaneously could cause race conditions.\r\n\r\n**Solution**: Database transactions with row locking in the claim endpoint. First to commit wins, others get an error message.\r\n\r\n### Stale Leaderboard Data\r\n\r\n**Challenge**: Leaderboards showing outdated info after point awards.\r\n\r\n**Solution**: AJAX polling every 30 seconds. After claiming an egg, immediately trigger a leaderboard update. Simple caching prevents database hammering.\r\n\r\n### Mobile UI Issues\r\n\r\n**Challenge**: Complex layouts breaking on small screens, buttons too small, timers not visible.\r\n\r\n**Solution**: Bootstrap's grid system and mobile-first approach. Tested extensively on actual phones (borrowed from family members). Adjusted button sizes and spacing based on feedback.\r\n\r\n## What I'd Do Differently\r\n\r\nIf I were starting over with what I know now:\r\n\r\n**Use a Framework**: Laravel or Symfony would give me routing, auth, ORM, and testing tools out of the box. I learned a lot building from scratch, but it took way longer.\r\n\r\n**Write Tests**: Zero automated tests. Everything tested manually. Next time: PHPUnit for backend, proper test coverage.\r\n\r\n**Better Error Handling**: Used basic try-catch and error_log(). Should use a proper logging library with levels.\r\n\r\n**Implement Caching Earlier**: Added caching after performance issues appeared. Should have planned for it from the start.\r\n\r\n**Git From Day One**: Version 1 had sporadic commits. Version 2 better, but still not great. Future projects: proper Git workflow from line one.\r\n\r\n## Future Ideas\r\n\r\nFeatures that would be fun to add:\r\n\r\n- **Mobile App**: React Native version with push notifications when tasks unlock\r\n- **QR Code Integration**: Scan QR codes at locations to automatically claim eggs\r\n- **Team Mode**: Compete in teams with shared progress\r\n- **Photo Verification**: Upload photos as proof of finding eggs\r\n- **Multi-Language Support**: Interface text in multiple languages\r\n- **Social Features**: Share achievements, invite friends\r\n- **Difficulty Modes**: Easy/medium/hard versions of same event\r\n\r\nBut honestly? It does what it needs to do now. Might add these if there's demand, might not. Sometimes \"done\" is better than \"perfect.\"\r\n\r\n## Links and Resources\r\n\r\n- **GitHub Repository**: [github.com/tian102/Eggsplorer](https://github.com/tian102/Eggsplorer)\r\n- **Full Documentation**: See README.md in the repository for installation, setup, and usage guides\r\n\r\n## Final Thoughts\r\n\r\nEggsplorer is what happens when you combine a love for building things with an excuse to over-engineer something fun. It's not going to change the world, but it made my family's Easter better, taught me a bunch, and gave me something to work on during downtime.\r\n\r\nSometimes the best projects are the ones that make people smile. This one definitely does that.\r\n\r\nIf you end up using it for your own event, I'd love to hear about it. And if you find bugs (you probably will), feel free to open an issue or submit a PR. It's a hobby project, but I'm always up for making it better.\r\n\r\n---\r\n\r\n**Tech Stack**: PHP • MySQL • JavaScript • Bootstrap • AJAX • Chart.js\r\n\r\n**Development Time**: ~3 weeks for version 1, ~3 months for version 2 (part-time)\r\n\r\n**Lines of Code**: ~15,000 across all files\r\n\r\n*Built because I couldn't help myself. Refined because I actually cared. Used because it's genuinely fun.*\r\n",
    "assetsPath": "content/projects/posts/eggsplorer-platform/assets/",
    "projectPath": "content/projects/posts/eggsplorer-platform/"
  },
  {
    "slug": "portfolio-website",
    "title": "1. Portfolio Website with Markdown Content System",
    "description": "A vanilla JavaScript portfolio with custom markdown-based content management, built the hard way because I refused to learn Jekyll.",
    "tags": [
      "css",
      "js",
      "html",
      "markdown",
      "github",
      "node"
    ],
    "demo": "https://tianpretorius.github.io",
    "github": "https://github.com/tian102/tianpretorius.github.io",
    "image": "https://images.unsplash.com/photo-1487017159836-4e23ece2e4cf?w=1200&h=630&fit=crop",
    "coverImage": "https://images.unsplash.com/photo-1487017159836-4e23ece2e4cf?w=1200&h=630&fit=crop",
    "date": "2024-10-09",
    "content": "\r\n# Portfolio Website with Markdown Content System\r\n\r\n## Reinventing the Wheel\r\n\r\nI built this portfolio the hard way—no frameworks, no backend, no Jekyll—just Node.js, vanilla JavaScript, and a stubborn streak. Every markdown file, asset, and route is handled by a custom system I wrote myself. Sure, it took a bunch of hours to do what a few commands in Jekyll could’ve done, but along the way I learned everything about build automation, client-side routing, and modular site design—and now I have a portfolio that’s annoyingly mine.\r\n\r\n![Cover Image](https://images.unsplash.com/photo-1487017159836-4e23ece2e4cf?w=1200&h=630&fit=crop)\r\n\r\n## Project Overview\r\n\r\nThis portfolio was born from necessity (needing a place to showcase my work) and fueled by stubbornness (refusing to do things the easy way).\r\n\r\nGitHub Pages offers a fantastic tool called Jekyll that makes working with markdown files incredibly straightforward. It's mature, well-documented, and used by thousands of developers.\r\n\r\nI chose not to use it.\r\n\r\nWhy? Because learning \"just another tool\" felt like an investment of time I wasn't willing to make. Instead, I decided to reinvent the wheel—spending 10+ hours building a custom system to automate what I could have done with Jekyll in an afternoon.\r\n\r\nClassic developer move, right?\r\n\r\nBut in the process, I learned a lot, built something that's truly mine, and ended up with a portfolio system that works exactly the way I want it to.\r\n\r\n## Key Features\r\n\r\n- **Markdown-Based Content Management**: Write blog posts and project descriptions in markdown, complete with frontmatter for metadata\r\n- **Automated Build System**: Node.js script that parses markdown files and generates JSON data at build time\r\n- **Modular Directory Structure**: Each post lives in its own directory with dedicated assets folder for images and resources\r\n- **Client-Side Routing**: Dynamic navigation using the History API, no page reloads needed\r\n- **Zero Backend Dependencies**: Everything is statically generated and served, keeping hosting costs at exactly $0\r\n- **Responsive Design**: Mobile-first approach with smooth animations and transitions\r\n\r\n## Technology Stack\r\n\r\n### Frontend\r\n- **Vanilla JavaScript**: No frameworks—just pure JS for maximum control and minimal bundle size\r\n- **HTML5 & CSS3**: Semantic markup with modern CSS features (custom properties, grid, flexbox)\r\n- **marked.js**: Markdown parsing library for converting content to HTML\r\n\r\n### Content Management\r\n- **Markdown with Frontmatter**: Write content in markdown files with YAML metadata\r\n- **Modular Structure**: Each post in its own directory (`content/blog/posts/post-name/index.md`)\r\n- **Asset Organization**: Images and resources stored alongside their content in `assets/` subdirectories\r\n\r\n### Build System\r\n- **Node.js Script**: Custom build pipeline that:\r\n  - Scans content directories for markdown files\r\n  - Parses frontmatter and content\r\n  - Generates structured JSON data files\r\n  - Processes image paths and metadata\r\n- **GitHub Actions**: Automated builds on push that regenerate content JSON\r\n\r\n### Hosting & Deployment\r\n- **GitHub Pages**: Free static hosting with custom domain support\r\n- **Git-Based Workflow**: Push to main branch triggers automatic deployment\r\n\r\n## Architecture & Design Decisions\r\n\r\n### Why Vanilla JavaScript Over Frameworks?\r\n\r\nFor a portfolio site, frameworks felt like overkill. The performance overhead, build complexity, and learning curve didn't justify the benefits. With vanilla JS, I got:\r\n- ~50KB total JavaScript (unminified)\r\n- Sub-100ms page transitions\r\n- Complete control over every interaction\r\n- No build step for the frontend (just for content)\r\n\r\n### The Jekyll Stubbornness Story\r\n\r\nGitHub Pages has built-in Jekyll support. It's designed for exactly this use case—turning markdown files into websites. It handles frontmatter, templating, and asset management automatically.\r\n\r\nBut I didn't want to learn Ruby. I didn't want to configure another tool. I didn't want to deal with Liquid templates.\r\n\r\nSo instead, I built my own system in Node.js that:\r\n1. Recursively scans content directories\r\n2. Reads markdown files and parses frontmatter\r\n3. Extracts metadata (title, date, tags, etc.)\r\n4. Generates clean JSON data structures\r\n5. Handles asset paths and images\r\n\r\nWas this necessary? Absolutely not.\r\n\r\nDid it take longer than learning Jekyll? Probably.\r\n\r\nDo I regret it? Not really. I learned a ton about file systems, markdown parsing, and build automation. Plus, I now have a system that works exactly how I want it to, with no magic happening behind the scenes.\r\n\r\n### Modular Content Structure\r\n\r\nOne thing I did get right: the directory structure. Each blog post and project lives in its own folder:\r\n\r\n```\r\ncontent/\r\n├── blog/\r\n│   └── posts/\r\n│       └── my-post/\r\n│           ├── index.md\r\n│           └── assets/\r\n│               └── image.jpg\r\n└── projects/\r\n    └── posts/\r\n        └── my-project/\r\n            ├── index.md\r\n            └── assets/\r\n                └── screenshot.png\r\n```\r\n\r\nThis keeps content organized, makes assets easy to find, and means I can move posts around without breaking image paths.\r\n\r\n### Build Time vs Runtime\r\n\r\nI made a key decision early on: process content at build time, not runtime.\r\n\r\nInstead of fetching markdown files and parsing them in the browser, the build script pre-processes everything into JSON. This means:\r\n- Faster page loads (no parsing overhead)\r\n- Better SEO (content is available immediately)\r\n- Simpler client-side code\r\n- Clear separation between content and presentation\r\n\r\nThe trade-off? I have to run `npm run build` every time I add or update content. But with GitHub Actions, that's automated anyway.\r\n\r\n## Results & Outcomes\r\n\r\n### Performance\r\n- **JavaScript Bundle**: ~50KB unminified (could be smaller with minification)\r\n- **Page Load Time**: Sub-second for initial load\r\n- **Navigation Speed**: <100ms transitions between pages\r\n- **No Backend**: Zero server costs, no database overhead\r\n\r\n### Developer Experience\r\n- **Content Workflow**: Write markdown → Push to GitHub → Automatic build and deploy\r\n- **Easy Updates**: Just edit a markdown file, no need to touch code\r\n- **Asset Management**: Images live next to content, no path confusion\r\n- **Version Control**: Everything in git means full history and easy rollbacks\r\n\r\n### Learning Outcomes\r\n- **File System Operations**: Deep dive into Node.js fs module and recursive directory scanning\r\n- **Markdown Parsing**: Understanding frontmatter, AST parsing, and content extraction\r\n- **Build Automation**: Creating custom build pipelines and CI/CD integration\r\n- **History API**: Client-side routing without frameworks\r\n- **The Value of Existing Tools**: Sometimes the wheel doesn't need reinventing (but it's fun anyway)\r\n\r\n## Challenges & Lessons Learned\r\n\r\n### The Jekyll Realization\r\n\r\nAbout halfway through building my custom system, I realized Jekyll would have solved 90% of my problems out of the box. But by then, I was committed. And honestly? I learned more doing it the hard way.\r\n\r\nWould I recommend this approach to others? Probably not. But if you're the stubborn type who likes to understand every piece of the puzzle, building your own system is incredibly educational.\r\n\r\n### GitHub Pages Quirks\r\n\r\nGitHub Pages is great, but it has its peculiarities:\r\n- Deployment can be finicky if you don't understand the build process\r\n- Custom domains require specific DNS configuration\r\n- There's a learning curve to the Actions workflow\r\n- You're limited to static content (which was actually a good constraint)\r\n\r\n### The 10-Hour Automation Rule\r\n\r\nThere's a developer joke: \"I spent 10 hours automating a task that takes 2 minutes to do manually.\"\r\n\r\nThat's basically what I did here. Jekyll would have been the 2-minute solution. My custom build system was the 10-hour one.\r\n\r\nBut here's the thing: I don't regret it. Those 10 hours taught me things I wouldn't have learned otherwise. And now I have a portfolio that's uniquely mine.\r\n\r\n## Future Improvements\r\n\r\n- **Search Functionality**: Add client-side search across blog posts and projects\r\n- **Tag Filtering**: Filter content by technology tags\r\n- **RSS Feed**: Generate an RSS feed for the blog\r\n- **Dark Mode**: Add theme toggle for dark mode support\r\n- **Performance Optimization**: Minify and bundle JavaScript\r\n- **Progressive Web App**: Add service worker for offline support\r\n\r\n## Key Takeaways\r\n\r\n1. **Constraints Drive Creativity**: Having no budget forced me to find free solutions and build creatively\r\n2. **Stubbornness Has Its Place**: Sometimes doing things the hard way teaches you more than the easy way\r\n3. **Ownership Matters**: Building my own system means I understand every piece of it\r\n4. **But Also**: Existing tools exist for a reason—don't always reinvent the wheel (even though I did)\r\n5. **Build What You Need**: This portfolio isn't perfect, but it's mine and it works\r\n\r\n---\r\n\r\n*Built with stubbornness, vanilla JavaScript, and way more custom code than was strictly necessary.*\r\n",
    "assetsPath": "content/projects/posts/portfolio-website/assets/",
    "projectPath": "content/projects/posts/portfolio-website/"
  }
]