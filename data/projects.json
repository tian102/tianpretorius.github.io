[
  {
    "slug": "3-portfolio-website",
    "title": "3. Portfolio Website with Markdown Content System",
    "description": "A vanilla JavaScript portfolio with custom markdown-based content management, built the hard way because I refused to learn Jekyll.",
    "tags": [
      "css",
      "js",
      "html",
      "markdown",
      "github",
      "node"
    ],
    "demo": "https://tianpretorius.github.io",
    "github": "https://github.com/tian102/tianpretorius.github.io",
    "image": "https://images.unsplash.com/photo-1487017159836-4e23ece2e4cf?w=1200&h=630&fit=crop",
    "coverImage": "https://images.unsplash.com/photo-1487017159836-4e23ece2e4cf?w=1200&h=630&fit=crop",
    "date": "2025-10-10",
    "content": "\r\n# Portfolio Website with Markdown Content System\r\n\r\n## Reinventing the Wheel\r\n\r\nI built this portfolio the hard way—no frameworks, no backend, no Jekyll—just Node.js, vanilla JavaScript, and a stubborn streak. Every markdown file, asset, and route is handled by a custom system I wrote myself. Sure, it took a bunch of hours to do what a few commands in Jekyll could’ve done, but along the way I learned everything about build automation, client-side routing, and modular site design—and now I have a portfolio that’s annoyingly mine.\r\n\r\n![Cover Image](https://images.unsplash.com/photo-1487017159836-4e23ece2e4cf?w=1200&h=630&fit=crop)\r\n\r\n## Project Overview\r\n\r\nThis portfolio was born from necessity (needing a place to showcase my work) and fueled by stubbornness (refusing to do things the easy way).\r\n\r\nGitHub Pages offers a fantastic tool called Jekyll that makes working with markdown files incredibly straightforward. It's mature, well-documented, and used by thousands of developers.\r\n\r\nI chose not to use it.\r\n\r\nWhy? Because learning \"just another tool\" felt like an investment of time I wasn't willing to make. Instead, I decided to reinvent the wheel—spending 10+ hours building a custom system to automate what I could have done with Jekyll in an afternoon.\r\n\r\nClassic developer move, right?\r\n\r\nBut in the process, I learned a lot, built something that's truly mine, and ended up with a portfolio system that works exactly the way I want it to.\r\n\r\n## Key Features\r\n\r\n- **Markdown-Based Content Management**: Write blog posts and project descriptions in markdown, complete with frontmatter for metadata\r\n- **Automated Build System**: Node.js script that parses markdown files and generates JSON data at build time\r\n- **Modular Directory Structure**: Each post lives in its own directory with dedicated assets folder for images and resources\r\n- **Client-Side Routing**: Dynamic navigation using the History API, no page reloads needed\r\n- **Zero Backend Dependencies**: Everything is statically generated and served, keeping hosting costs at exactly $0\r\n- **Responsive Design**: Mobile-first approach with smooth animations and transitions\r\n\r\n## Technology Stack\r\n\r\n### Frontend\r\n- **Vanilla JavaScript**: No frameworks—just pure JS for maximum control and minimal bundle size\r\n- **HTML5 & CSS3**: Semantic markup with modern CSS features (custom properties, grid, flexbox)\r\n- **marked.js**: Markdown parsing library for converting content to HTML\r\n\r\n### Content Management\r\n- **Markdown with Frontmatter**: Write content in markdown files with YAML metadata\r\n- **Modular Structure**: Each post in its own directory (`content/blog/posts/post-name/index.md`)\r\n- **Asset Organization**: Images and resources stored alongside their content in `assets/` subdirectories\r\n\r\n### Build System\r\n- **Node.js Script**: Custom build pipeline that:\r\n  - Scans content directories for markdown files\r\n  - Parses frontmatter and content\r\n  - Generates structured JSON data files\r\n  - Processes image paths and metadata\r\n- **GitHub Actions**: Automated builds on push that regenerate content JSON\r\n\r\n### Hosting & Deployment\r\n- **GitHub Pages**: Free static hosting with custom domain support\r\n- **Git-Based Workflow**: Push to main branch triggers automatic deployment\r\n\r\n## Architecture & Design Decisions\r\n\r\n### Why Vanilla JavaScript Over Frameworks?\r\n\r\nFor a portfolio site, frameworks felt like overkill. The performance overhead, build complexity, and learning curve didn't justify the benefits. With vanilla JS, I got:\r\n- ~50KB total JavaScript (unminified)\r\n- Sub-100ms page transitions\r\n- Complete control over every interaction\r\n- No build step for the frontend (just for content)\r\n\r\n### The Jekyll Stubbornness Story\r\n\r\nGitHub Pages has built-in Jekyll support. It's designed for exactly this use case—turning markdown files into websites. It handles frontmatter, templating, and asset management automatically.\r\n\r\nBut I didn't want to learn Ruby. I didn't want to configure another tool. I didn't want to deal with Liquid templates.\r\n\r\nSo instead, I built my own system in Node.js that:\r\n1. Recursively scans content directories\r\n2. Reads markdown files and parses frontmatter\r\n3. Extracts metadata (title, date, tags, etc.)\r\n4. Generates clean JSON data structures\r\n5. Handles asset paths and images\r\n\r\nWas this necessary? Absolutely not.\r\n\r\nDid it take longer than learning Jekyll? Probably.\r\n\r\nDo I regret it? Not really. I learned a ton about file systems, markdown parsing, and build automation. Plus, I now have a system that works exactly how I want it to, with no magic happening behind the scenes.\r\n\r\n### Modular Content Structure\r\n\r\nOne thing I did get right: the directory structure. Each blog post and project lives in its own folder:\r\n\r\n```\r\ncontent/\r\n├── blog/\r\n│   └── posts/\r\n│       └── my-post/\r\n│           ├── index.md\r\n│           └── assets/\r\n│               └── image.jpg\r\n└── projects/\r\n    └── posts/\r\n        └── my-project/\r\n            ├── index.md\r\n            └── assets/\r\n                └── screenshot.png\r\n```\r\n\r\nThis keeps content organized, makes assets easy to find, and means I can move posts around without breaking image paths.\r\n\r\n### Build Time vs Runtime\r\n\r\nI made a key decision early on: process content at build time, not runtime.\r\n\r\nInstead of fetching markdown files and parsing them in the browser, the build script pre-processes everything into JSON. This means:\r\n- Faster page loads (no parsing overhead)\r\n- Better SEO (content is available immediately)\r\n- Simpler client-side code\r\n- Clear separation between content and presentation\r\n\r\nThe trade-off? I have to run `npm run build` every time I add or update content. But with GitHub Actions, that's automated anyway.\r\n\r\n## Results & Outcomes\r\n\r\n### Performance\r\n- **JavaScript Bundle**: ~50KB unminified (could be smaller with minification)\r\n- **Page Load Time**: Sub-second for initial load\r\n- **Navigation Speed**: <100ms transitions between pages\r\n- **No Backend**: Zero server costs, no database overhead\r\n\r\n### Developer Experience\r\n- **Content Workflow**: Write markdown → Push to GitHub → Automatic build and deploy\r\n- **Easy Updates**: Just edit a markdown file, no need to touch code\r\n- **Asset Management**: Images live next to content, no path confusion\r\n- **Version Control**: Everything in git means full history and easy rollbacks\r\n\r\n### Learning Outcomes\r\n- **File System Operations**: Deep dive into Node.js fs module and recursive directory scanning\r\n- **Markdown Parsing**: Understanding frontmatter, AST parsing, and content extraction\r\n- **Build Automation**: Creating custom build pipelines and CI/CD integration\r\n- **History API**: Client-side routing without frameworks\r\n- **The Value of Existing Tools**: Sometimes the wheel doesn't need reinventing (but it's fun anyway)\r\n\r\n## Challenges & Lessons Learned\r\n\r\n### The Jekyll Realization\r\n\r\nAbout halfway through building my custom system, I realized Jekyll would have solved 90% of my problems out of the box. But by then, I was committed. And honestly? I learned more doing it the hard way.\r\n\r\nWould I recommend this approach to others? Probably not. But if you're the stubborn type who likes to understand every piece of the puzzle, building your own system is incredibly educational.\r\n\r\n### GitHub Pages Quirks\r\n\r\nGitHub Pages is great, but it has its peculiarities:\r\n- Deployment can be finicky if you don't understand the build process\r\n- Custom domains require specific DNS configuration\r\n- There's a learning curve to the Actions workflow\r\n- You're limited to static content (which was actually a good constraint)\r\n\r\n### The 10-Hour Automation Rule\r\n\r\nThere's a developer joke: \"I spent 10 hours automating a task that takes 2 minutes to do manually.\"\r\n\r\nThat's basically what I did here. Jekyll would have been the 2-minute solution. My custom build system was the 10-hour one.\r\n\r\nBut here's the thing: I don't regret it. Those 10 hours taught me things I wouldn't have learned otherwise. And now I have a portfolio that's uniquely mine.\r\n\r\n## Future Improvements\r\n\r\n- **Search Functionality**: Add client-side search across blog posts and projects\r\n- **Tag Filtering**: Filter content by technology tags\r\n- **RSS Feed**: Generate an RSS feed for the blog\r\n- **Dark Mode**: Add theme toggle for dark mode support\r\n- **Performance Optimization**: Minify and bundle JavaScript\r\n- **Progressive Web App**: Add service worker for offline support\r\n\r\n## Key Takeaways\r\n\r\n1. **Constraints Drive Creativity**: Having no budget forced me to find free solutions and build creatively\r\n2. **Stubbornness Has Its Place**: Sometimes doing things the hard way teaches you more than the easy way\r\n3. **Ownership Matters**: Building my own system means I understand every piece of it\r\n4. **But Also**: Existing tools exist for a reason—don't always reinvent the wheel (even though I did)\r\n5. **Build What You Need**: This portfolio isn't perfect, but it's mine and it works\r\n\r\n---\r\n\r\n*Built with stubbornness, vanilla JavaScript, and way more custom code than was strictly necessary.*\r\n",
    "assetsPath": "content/projects/posts/3-portfolio-website/assets/",
    "projectPath": "content/projects/posts/3-portfolio-website/"
  },
  {
    "slug": "2-eggsplorer-platform",
    "title": "2. Eggsplorer - Interactive Hunt Platform",
    "description": "A web-based platform for creating and running digital scavenger hunts, Easter egg hunts, and trivia challenges with real-time tracking and leaderboards.",
    "tags": [
      "php",
      "mysql",
      "javascript",
      "bootstrap",
      "ajax",
      "web-development"
    ],
    "demo": "",
    "github": "https://github.com/tian102/Eggsplorer",
    "image": "content/projects/posts/2-eggsplorer-platform/./assets/Eggsplorer.png",
    "coverImage": "content/projects/posts/2-eggsplorer-platform/./assets/Eggsplorer.png",
    "date": "2025-10-8",
    "content": "\r\n# Eggsplorer - Interactive Hunt Platform\r\n\r\nA full-stack web application that transforms traditional scavenger hunts into interactive digital experiences. Built for Easter events, it combines online challenges with physical hunting through a two-phase system: solve the puzzle, find the egg, claim your points.\r\n\r\n![Eggsplorer Banner](./assets/Eggsplorer.png)\r\n\r\n## The Story Behind It\r\n\r\nThis started as a \"wouldn't it be fun if...\" idea three days before Easter last year. I was hosting and wanted to make the traditional egg hunt more engaging. The first version was rough—buggy, barely functional, held together with duct tape and hope—but people loved it.\r\n\r\nThis year, I rebuilt it properly. Fixed the bugs, overhauled the UI, added all the features I wished existed last time, and turned it into a real platform that could handle any type of hunt event.\r\n\r\nIt's definitely over-engineered for a family Easter party, but that's kind of the point. Sometimes you build things not because they're necessary, but because they're interesting.\r\n\r\n## How It Works\r\n\r\nThe concept is simple but effective:\r\n\r\n### Two-Phase Challenge System\r\n\r\n**Phase 1: The Mental Game**  \r\nParticipants solve digital challenges (trivia questions, riddles, math problems, whatever you want) on their phones or computers. Get it right, unlock the location clue.\r\n\r\n**Phase 2: The Physical Hunt**  \r\nOnce solved, a 10-minute timer starts. They have to find the physical \"egg\" (could be a QR code, object, location—anything) and claim it before time runs out. No claiming, no points.\r\n\r\nThis approach:\r\n- Prevents the fastest runner from dominating everything\r\n- Adds tension with the timer countdown\r\n- Works for all ages and skill levels\r\n- Can be played indoors if weather doesn't cooperate\r\n- Creates little moments of excitement (\"I got it!\" followed by frantic searching)\r\n\r\n### Sequential Tasks\r\n\r\nTasks unlock in sequence—you can't skip ahead to easier ones. This keeps everyone progressing at their own pace and prevents one person from hogging all the eggs.\r\n\r\n### Persistent Hints\r\n\r\nNeed help? Reveal a hint. It'll cost you a few points, but once revealed, it stays visible even if you refresh the page. No accidental hint loss like in version 1.\r\n\r\n### Live Leaderboards\r\n\r\nPoints update in real-time (well, every 30 seconds) so everyone can see the competition. Watching people's reactions when they climb the board after claiming an egg never gets old.\r\n\r\n## Key Features\r\n\r\n### For Participants\r\n- **Clean, Mobile-Friendly Interface**: Works smoothly on phones, tablets, and computers. Built with Bootstrap so it looks decent everywhere.\r\n- **Multiple Event Types**: Easter egg hunts, treasure hunts, scavenger hunts, trivia challenges—same platform, different themes.\r\n- **Progressive Task System**: Tasks unlock in order, each with its own points value and difficulty.\r\n- **Timer-Based Egg Claiming**: 10-minute countdown creates urgency without being overwhelming.\r\n- **Hint System**: Get stuck? Reveal hints for a small point penalty. They persist so you won't lose them.\r\n- **Real-Time Leaderboard**: See your ranking update as you and others claim eggs.\r\n- **Progress Tracking**: Visual indicators show which tasks you've completed and which eggs you've claimed.\r\n- **Automatic Task Reopening**: Timer expired? Task reopens automatically so you can try again.\r\n\r\n![User Dashboard](./assets/4.%20logged_in_welcome_page.jpeg)\r\n*Personalized dashboard showing active events and leaderboard*\r\n\r\n### For Organizers (Admin Panel)\r\n- **Event Management**: Create events with custom names, descriptions, start/end times, and types.\r\n- **Task Builder**: Add tasks with questions, answers, point values, and sequence ordering.\r\n- **Hint Configuration**: Set up hints with time delays and point costs.\r\n- **User Management**: See who's registered, promote admins, monitor activity.\r\n- **Live Monitoring**: Watch event progress in real-time, see who's stuck, who's winning.\r\n- **JSON Templates**: Export entire events as JSON files, edit them, import for quick setup.\r\n- **Analytics Dashboard**: View completion rates, engagement metrics, and task difficulty analysis.\r\n- **Activity Logs**: Complete audit trail of all user actions for debugging and oversight.\r\n\r\n![Admin Dashboard](./assets/8.%20admin_dashboard.jpeg)\r\n*Admin overview with key metrics and system status*\r\n\r\n## Technical Overview\r\n\r\n### The Stack\r\n\r\nBuilt with technologies I already knew—no time to learn frameworks when Easter's three days away:\r\n\r\n- **PHP 8**: Server-side logic and session management\r\n- **MySQL**: Database with proper relational structure\r\n- **JavaScript (Vanilla)**: AJAX interactions, timers, dynamic UI updates\r\n- **Bootstrap 5**: Responsive UI framework for consistent styling\r\n- **Chart.js**: Analytics visualizations for the admin dashboard\r\n\r\n### Why These Choices?\r\n\r\n**PHP/MySQL**: I knew them. XAMPP makes local hosting trivial. No server costs. Works great for small-to-medium events (tested with 100+ concurrent users without issues).\r\n\r\n**No Framework**: For something this size, frameworks felt like overkill. Vanilla PHP with good organization is perfectly fine. Plus, I learned more by building the structure myself.\r\n\r\n**Bootstrap**: I'm not a designer. Bootstrap makes things look good without requiring design skills. It's responsive out of the box, which matters when everyone's on their phones.\r\n\r\n**Vanilla JavaScript**: The interactivity isn't complex enough to justify React/Vue. Event listeners and fetch calls handle everything needed.\r\n\r\n## Architecture Highlights\r\n\r\n### Database Design\r\n\r\nThe schema tracks everything needed for a smooth experience:\r\n\r\n- **users**: Login credentials, admin status\r\n- **events**: Event details, start/end times, types\r\n- **tasks**: Questions, answers, points, sequence order\r\n- **hints**: Hint text, time delays, point costs\r\n- **event_participants**: Who's in which events, their total points\r\n- **user_tasks**: Task completion status, timestamps, egg claimed status\r\n- **user_hints**: Which hints have been revealed to whom\r\n- **activity_logs**: Full audit trail of all actions\r\n\r\nForeign keys enforce data integrity. Indexes on frequently-joined columns keep queries fast (leaderboard queries run in ~15ms even with lots of participants).\r\n\r\n### State Management\r\n\r\nThe server is the single source of truth for everything that matters:\r\n\r\n**Timer Logic**: When you complete a task, we store the timestamp. When you try to claim an egg, we calculate how much time has actually passed server-side. No client-side manipulation possible.\r\n\r\n**Points**: All point calculations happen on the server. AJAX calls send the action, server validates and responds with updated totals.\r\n\r\n**Progress**: Task completion, egg claiming, hint reveals—all tracked in the database and validated on every action.\r\n\r\nThe client just displays what the server tells it. Keeps things honest.\r\n\r\n### AJAX Layer\r\n\r\nEverything that can be async, is:\r\n\r\n- Submit answers without page reload\r\n- Reveal hints instantly\r\n- Claim eggs with feedback\r\n- Update leaderboards every 30 seconds\r\n- Leave events gracefully\r\n\r\nEach AJAX endpoint validates the session, checks permissions, performs the action, and returns structured JSON. Clean separation of concerns.\r\n\r\n### Security\r\n\r\nNot trying to protect nuclear codes, but built in common-sense security:\r\n\r\n- **SQL Injection Prevention**: Parameterized queries everywhere using PDO\r\n- **CSRF Protection**: Tokens on all forms and AJAX requests\r\n- **XSS Prevention**: All user input sanitized before display\r\n- **Password Security**: bcrypt hashing, never stored plaintext\r\n- **Session Security**: HTTP-only cookies, session regeneration, timeouts\r\n- **Admin Protection**: All admin routes check permissions\r\n\r\nGood enough for a family Easter party and then some.\r\n\r\n## Development Journey\r\n\r\n### Version 1 (Last Year)\r\n\r\nBuilt in about 3 days. Features:\r\n- Basic login/registration\r\n- Task display and answer submission\r\n- Egg hunt timer (that worked... mostly)\r\n- Point tracking (sometimes)\r\n- Minimal UI (functional but ugly)\r\n\r\nProblems:\r\n- Timer could be cheated by refreshing\r\n- No admin panel (used phpMyAdmin during event)\r\n- Concurrent claims could cause issues\r\n- Leaderboard rarely updated correctly\r\n- UI was rough on mobile\r\n- I spent the event debugging instead of participating\r\n\r\nResult: Everyone had fun anyway. Got great feedback on what to improve.\r\n\r\n### Version 2 (This Year)\r\n\r\nComplete rebuild over a few weeks. Added:\r\n- Server-authoritative timers (no more cheating)\r\n- Full-featured admin panel\r\n- Proper AJAX architecture\r\n- Persistent hints\r\n- Clean, responsive UI\r\n- JSON template system\r\n- Analytics dashboard\r\n- Activity logging\r\n- Database optimizations\r\n\r\nResult: Actually works reliably. Can participate in events instead of debugging. Looks professional enough that I'm not embarrassed to show people.\r\n\r\n### What I Learned\r\n\r\n**Start Simple**: Version 1 proved the concept. Version 2 made it good. If I'd tried to build version 2 from scratch, I'd still be working on it.\r\n\r\n**User Feedback Matters**: Every complaint from last year became a feature this year. Persistent hints, automatic task reopening, better mobile UI—all from user feedback.\r\n\r\n**Good Enough Is Good Enough**: It's not the most elegant code. It's not using cutting-edge tech. But it works, it's maintainable, and people enjoy using it. That's what matters.\r\n\r\n**Overengineering Can Be Fun**: Yes, I over-engineered an Easter egg hunt. No regrets. The process of building taught me things, and now I have a reusable platform for any hunt-style event.\r\n\r\n## Screenshots\r\n\r\n### Event Participation Flow\r\n\r\n<table>\r\n  <tr>\r\n    <td width=\"33%\">\r\n      <img src=\"./assets/5. egg_hunt.jpeg\" alt=\"Event View\">\r\n      <p align=\"center\"><em>Event task list and progress tracking</em></p>\r\n    </td>\r\n    <td width=\"33%\">\r\n      <img src=\"./assets/6. egg_search.jpg\" alt=\"Egg Hunt\">\r\n      <p align=\"center\"><em>Egg hunt phase with 10-minute timer</em></p>\r\n    </td>\r\n    <td width=\"33%\">\r\n      <img src=\"./assets/7. egg_found.jpeg\" alt=\"Success\">\r\n      <p align=\"center\"><em>Successful egg claim confirmation</em></p>\r\n    </td>\r\n  </tr>\r\n</table>\r\n\r\n### Admin Panel\r\n\r\n<table>\r\n  <tr>\r\n    <td width=\"50%\">\r\n      <img src=\"./assets/9. admin_manage_events.jpeg\" alt=\"Manage Events\">\r\n      <p align=\"center\"><em>Event management interface</em></p>\r\n    </td>\r\n    <td width=\"50%\">\r\n      <img src=\"./assets/11. admin_analytics_dashboard.jpeg\" alt=\"Analytics\">\r\n      <p align=\"center\"><em>Analytics dashboard with Chart.js visualizations</em></p>\r\n    </td>\r\n  </tr>\r\n</table>\r\n\r\n## Cool Features I'm Proud Of\r\n\r\n### JSON Template System\r\n\r\nYou can export an entire event (tasks, hints, settings) as a JSON file, edit it, and import it to create a new event. Makes testing fast and lets you share event templates.\r\n\r\n```json\r\n{\r\n  \"event\": {\r\n    \"name\": \"Easter Hunt 2025\",\r\n    \"event_type\": \"Egg Hunt\",\r\n    \"start_datetime\": \"2025-04-20 10:00:00\"\r\n  },\r\n  \"tasks\": [\r\n    {\r\n      \"title\": \"Find the Golden Egg\",\r\n      \"expected_answer\": \"golden\",\r\n      \"points\": 100,\r\n      \"hints\": [\r\n        {\"hint_text\": \"Check the garden\"}\r\n      ]\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nThe template handler validates everything, uses database transactions for atomicity, and provides clear error messages if something's wrong.\r\n\r\n### Automatic Task Reopening\r\n\r\nTimer expired before you found the egg? The task automatically reopens via AJAX. You get a notification and can try again. No manual intervention needed.\r\n\r\n### Persistent Hint Display\r\n\r\nOnce a hint is revealed, it stays visible. The database tracks which hints you've seen, so refreshing won't lose them. Small detail, huge UX improvement.\r\n\r\n### Real-Time-ish Updates\r\n\r\nLeaderboards update every 30 seconds via AJAX polling. Not true real-time (that would need WebSockets), but feels responsive enough and keeps server load reasonable.\r\n\r\n### Admin Analytics\r\n\r\nThe analytics dashboard shows:\r\n- Event completion rates\r\n- Average time per task\r\n- Hint usage patterns (indicates task difficulty)\r\n- Participant engagement over time\r\n\r\nBuilt with Chart.js, looks professional, actually useful for tuning event difficulty.\r\n\r\n## Challenges Overcome\r\n\r\n### The Timer Problem\r\n\r\n**Challenge**: Client-side timers can be manipulated (refresh page, change system clock).\r\n\r\n**Solution**: Store task completion timestamp in database. Calculate elapsed time server-side on every page load and when claiming eggs. JavaScript timer is just for display.\r\n\r\n### Concurrent Claims\r\n\r\n**Challenge**: Multiple people claiming same egg simultaneously could cause race conditions.\r\n\r\n**Solution**: Database transactions with row locking in the claim endpoint. First to commit wins, others get an error message.\r\n\r\n### Stale Leaderboard Data\r\n\r\n**Challenge**: Leaderboards showing outdated info after point awards.\r\n\r\n**Solution**: AJAX polling every 30 seconds. After claiming an egg, immediately trigger a leaderboard update. Simple caching prevents database hammering.\r\n\r\n### Mobile UI Issues\r\n\r\n**Challenge**: Complex layouts breaking on small screens, buttons too small, timers not visible.\r\n\r\n**Solution**: Bootstrap's grid system and mobile-first approach (tested extensively on my own phone). Adjusted button sizes and spacing based on look and feel.\r\n\r\n## What I'd Do Differently\r\n\r\nIf I were starting over with what I know now:\r\n\r\n**Use a Framework**: Laravel or Symfony would give me routing, auth, ORM, and testing tools out of the box. I learned a lot building from scratch, but it took way longer.\r\n\r\n**Write Tests**: Zero automated tests. Everything tested manually. Next time: PHPUnit for backend, proper test coverage.\r\n\r\n**Better Error Handling**: Used basic try-catch and error_log(). Should use a proper logging library with levels.\r\n\r\n**Implement Caching Earlier**: Added caching after performance issues appeared. Should have planned for it from the start.\r\n\r\n**Git From Day One**: Version 1 had sporadic commits. Version 2 better, but still not great. Future projects: proper Git workflow from line one.\r\n\r\n## Future Ideas\r\n\r\nFeatures that would be fun to add:\r\n\r\n- **Mobile App**: React Native version with push notifications when tasks unlock\r\n- **QR Code Integration**: Scan QR codes at locations to automatically claim eggs\r\n- **Team Mode**: Compete in teams with shared progress\r\n- **Photo Verification**: Upload photos as proof of finding eggs\r\n- **Multi-Language Support**: Interface text in multiple languages\r\n- **Social Features**: Share achievements, invite friends\r\n- **Difficulty Modes**: Easy/medium/hard versions of same event\r\n\r\nBut honestly? It does what it needs to do now. Might add these if there's demand, might not. Sometimes \"done\" is better than \"perfect.\"\r\n\r\n## Links and Resources\r\n\r\n- **GitHub Repository**: [github.com/tian102/Eggsplorer](https://github.com/tian102/Eggsplorer)\r\n- **Full Documentation**: See README.md in the repository for installation, setup, and usage guides\r\n\r\n## Final Thoughts\r\n\r\nEggsplorer is what happens when you combine a love for building things with an excuse to over-engineer something fun. It's not going to change the world, but it made Easter a tad more interesting, taught me a bunch, and gave me something to work on during downtime.\r\n\r\nSometimes the best projects are the ones that make people smile. This one definitely does that.\r\n\r\nIf you end up using it for your own event, I'd love to hear about it. And if you find bugs (you probably will), feel free to open an issue or submit a PR. It's a hobby project, but I'm always up for making it better.\r\n\r\n---\r\n\r\n**Tech Stack**: PHP • MySQL • JavaScript • Bootstrap • AJAX • Chart.js\r\n\r\n**Development Time**: ~3 weeks for version 1, ~3 months for version 2 (part-time)\r\n\r\n**Lines of Code**: ~15,000 across all files\r\n\r\n*Built because I couldn't help myself. Refined because I actually cared. Used because it's genuinely fun.*\r\n",
    "assetsPath": "content/projects/posts/2-eggsplorer-platform/assets/",
    "projectPath": "content/projects/posts/2-eggsplorer-platform/"
  },
  {
    "slug": "1-bizqr-digital-cards",
    "title": "1. BizQR - Digital Business Card Platform",
    "description": "A self-hosted web app for digital business cards with QR codes—because paying monthly subscriptions to share your phone number felt wrong.",
    "tags": [
      "php",
      "mysql",
      "javascript",
      "bootstrap",
      "qr-codes",
      "web-development"
    ],
    "demo": "",
    "github": "https://github.com/tian102/BizQR",
    "image": "content/projects/posts/1-bizqr-digital-cards/./assets/logo.png",
    "coverImage": "content/projects/posts/1-bizqr-digital-cards/./assets/logo.png",
    "date": "2025-10-6",
    "content": "\r\n# BizQR - Digital Business Card Platform\r\n\r\n## Why I Built This\r\n\r\nI needed digital business cards. The kind with QR codes that people can scan at networking events. Simple enough, right?\r\n\r\nBut every service I looked at wanted a monthly subscription. $10, $15, even $30 a month—just to host what amounts to a contact page with a QR code. And if I ever stopped paying? All those QR codes I'd printed on flyers and business materials would point to... nothing.\r\n\r\nThat felt wrong. So I built BizQR over a few days—a self-hosted alternative where you own your data, your cards, and your QR codes. No subscriptions, no vendor lock-in, just a simple PHP app you can run on any cheap hosting.\r\n\r\n![BizQR Logo](./assets/logo.png)\r\n\r\n## The Problem with online Business Cards platforms\r\n\r\nHere's what bothered me about existing platforms:\r\n\r\n- **Recurring Fees**: Monthly charges for what's essentially a static page\r\n- **Vendor Lock-In**: Stop paying and your QR codes become useless\r\n- **Limited Control**: You're stuck with their design, their features, their limitations\r\n- **Privacy Concerns**: Your professional contacts live on someone else's server\r\n- **Uncertain Future**: What if they shut down? Change pricing? Get acquired?\r\n\r\nWith BizQR, you host it yourself. You control everything. And it costs whatever your hosting costs—which for most people is either free (if you're already hosting something) or a few dollars a month.\r\n\r\n## How It Works\r\n\r\nThe concept is dead simple:\r\n\r\n1. **Create a card**: Fill in your name, title, company, contact info. Upload a profile pic if you want.\r\n2. **Get a QR code**: Each card automatically generates a unique QR code and public URL.\r\n3. **Share it**: Print the QR code on business cards, flyers, conference badges—whatever.\r\n4. **Update anytime**: Change jobs? New phone number? Update once and the QR code still works.\r\n\r\nThe QR code never changes. The URL never breaks. Your contact info just stays current.\r\n\r\nOh, and visitors can download your info as a vCard file—one tap and you're in their phone's contacts. No app needed, no friction.\r\n\r\n## Key Features\r\n\r\n### For Users\r\n- **Simple Registration**: Create an account and start building cards immediately\r\n- **Card Management Dashboard**: View all your cards at a glance with quick access to edit or delete\r\n- **QR Code Generation**: Each card automatically generates a scannable QR code\r\n- **Public Profile Pages**: Clean, mobile-responsive card display optimized for quick information sharing\r\n- **vCard Support**: One-click contact export for easy saving\r\n- **Bulk Upload**: Create multiple cards at once via CSV import\r\n- **Profile Images**: Upload custom photos or use default placeholder\r\n- **Persistent Links**: Your card URL never changes, even when you update information\r\n\r\n\r\n*Modern landing page highlighting key features*\r\n\r\n### Technical Highlights\r\n- **Self-Hosted**: Run on your own server, keep your data\r\n- **Lightweight Stack**: PHP backend with MySQL database—simple, proven, reliable\r\n- **Responsive Design**: Built with Bootstrap 5, works perfectly on mobile devices\r\n- **Clean Code**: Well-organized structure with separation of concerns\r\n- **Easy Deployment**: Drop in XAMPP/LAMP stack and run initialization script\r\n- **No External Dependencies**: QR generation via API (can be swapped with local library if preferred)\r\n\r\n## User Journey\r\n\r\n### 1. Landing Page\r\nThe landing page introduces BizQR's value proposition with clear feature cards explaining the benefits of digital business cards.\r\n\r\n![Landing Page](./assets/0_landing_top.png)\r\n![Landing Page Features](./assets/1_landing_bottom.png)\r\n*Landing page with feature showcase*\r\n\r\n### 2. Authentication\r\nSimple registration and login system. Create an account with username, email, and password—no complex onboarding, just the essentials.\r\n\r\n![Login Page](./assets/2_login.png)\r\n*Clean login interface*\r\n\r\n### 3. Empty Dashboard\r\nNew users see an empty dashboard with clear prompts to create their first business card. The interface includes options for single card creation or bulk CSV upload.\r\n\r\n![Empty Dashboard](./assets/3_dashboard_empty.png)\r\n*Dashboard view for new users*\r\n\r\n### 4. Card Creation\r\nThe card creation form is straightforward: enter your details, upload an optional profile image, and submit. The form validates input and handles image uploads securely.\r\n\r\n![Create Business Card](./assets/4_create_new_business_card.png)\r\n*Card creation form with all necessary fields*\r\n\r\n### 5. Dashboard with Cards\r\nOnce cards are created, the dashboard displays them in a card grid layout. Each entry shows a preview of the profile, job title, company, and the generated QR code. Quick action buttons allow editing or deleting cards.\r\n\r\n![Dashboard with Cards](./assets/5_dashboard_with_entries.png)\r\n*Dashboard showing created business cards*\r\n\r\n### 6. Public Card View\r\nThe public-facing card is mobile-optimized and clean. It displays all contact information, profile photo, and provides a \"Save Contact\" button to download the vCard file.\r\n\r\n![Shared Business Card](./assets/6_business_card_shared.png)\r\n*Public view of a digital business card*\r\n\r\n## Technical Overview\r\n\r\n### The Stack\r\n\r\n**Backend**:\r\n- **PHP**: Server-side logic and routing\r\n- **MySQL**: Relational database for user and card data\r\n- **PDO**: Secure database interactions with prepared statements\r\n\r\n**Frontend**:\r\n- **HTML5 & CSS3**: Semantic markup and modern styling\r\n- **Bootstrap 5**: Responsive UI framework\r\n- **JavaScript**: Form validation and interactivity\r\n- **Font Awesome**: Icon library for visual elements\r\n\r\n**Infrastructure**:\r\n- **XAMPP/LAMP**: Local or production web server stack\r\n- **QR Code API**: External API for QR generation (easily replaceable)\r\n\r\n### Database Design\r\n\r\nSimple but effective schema:\r\n\r\n**users** table:\r\n- User authentication and account management\r\n- Hashed passwords for security\r\n- Email and username uniqueness constraints\r\n\r\n**business_cards** table:\r\n- Card content (name, title, company, contact info)\r\n- User ownership via foreign key\r\n- Public ID for sharing (prevents sequential ID enumeration)\r\n- Profile image path storage\r\n- Timestamps for creation and updates\r\n\r\nThe relationship is one-to-many: one user can have multiple business cards.\r\n\r\n### Architecture Highlights\r\n\r\n**MVC-Inspired Structure**:\r\n- `config/` - Database connection and initialization\r\n- `includes/` - Reusable header/footer components\r\n- `assets/` - CSS, JavaScript, images\r\n- Root level - Page controllers (dashboard, create, edit, etc.)\r\n\r\n**Security Considerations**:\r\n- Password hashing with PHP's `password_hash()`\r\n- SQL injection prevention via prepared statements\r\n- Session-based authentication\r\n- File upload validation (type, size)\r\n- Public ID generation to prevent ID guessing\r\n- Input sanitization on display\r\n\r\n**Key Implementation Details**:\r\n\r\n**Public ID Generation**: Each card gets a unique random string (not sequential database ID) for the public URL, preventing enumeration attacks.\r\n\r\n**vCard Generation**: Dynamically creates vCard files server-side with proper formatting for contact import compatibility.\r\n\r\n**Image Handling**: Uploaded profile images are stored in `uploads/` directory with validation for file types and size limits.\r\n\r\n**Bulk Upload**: CSV parsing allows administrators to quickly create multiple cards, useful for organizations issuing cards to employees or members.\r\n\r\n## Why PHP and MySQL?\r\n\r\nBecause they're boring. And boring is good.\r\n\r\nI could have used the latest JavaScript framework, built a fancy GraphQL API, containerized everything with Docker, and deployed to Kubernetes. But for what? So I could host a contact page?\r\n\r\nPHP and MySQL are:\r\n- Available on every $5/month shared hosting plan\r\n- Simple enough that anyone can deploy and maintain it\r\n- Battle-tested for decades\r\n- Overkill-free\r\n\r\nI wanted something you could drop into a XAMPP folder and just... run. No build steps, no npm, no complicated setup. You copy the files, import the database, and you're done.\r\n\r\nSometimes the boring choice is the right choice.\r\n\r\n## The Self-Hosting Philosophy\r\n\r\nHere’s the thing: I prefer to keep my professional identity in my own hands.\r\n\r\nIt’s not about mistrust—it’s about independence. SaaS platforms are built around subscriptions, and their goals don’t always align with mine. They focus on recurring revenue; I just want my information to remain accessible—no strings attached.\r\n\r\nWith BizQR:\r\n- You own the data\r\n- You control the uptime\r\n- You decide the features\r\n- You're not a product\r\n\r\nIf you print 1,000 business cards with a QR code on them, you want to know that code will work five years from now. With BizQR, that's your choice, not a vendor's.\r\n\r\n## Who's This For?\r\n\r\n**Freelancers**: Create different cards for different contexts—consulting work, side projects, volunteer roles. One system, multiple professional identities.\r\n\r\n**Small Businesses**: Issue cards to all employees without paying per-user fees. Everyone gets their own card, you keep your sanity.\r\n\r\n**Event Organizers**: Make temporary cards for staff or speakers that you can delete after the event. No lingering subscriptions.\r\n\r\n**Privacy-Conscious People**: Keep your contact info on your own server. You decide who has access to the data and for how long.\r\n\r\n**Anyone Who Prints Things**: If you're printing QR codes on physical materials, you want them to work forever. BizQR gives you that control.\r\n\r\n## What I Learned\r\n\r\n### Simple Doesn't Mean Easy\r\nBuilding something \"simple\" still requires getting the details right. Password hashing, SQL injection prevention, file upload validation—even a weekend project needs proper security.\r\n\r\n### Users Want Boring Features That Work\r\nNo one asked for fancy animations or AI-powered contact recommendations. They wanted: upload info, get QR code, share it. The simpler the flow, the better.\r\n\r\n### Self-Hosting Needs to Be Actually Easy\r\nIf deployment requires more than 5 steps, most people won't bother. I spent almost as much time simplifying the setup process as I did building the app.\r\n\r\n### Database Schema Matters Early\r\nI initially used sequential IDs in public URLs (like `/card.php?id=1`). Realized that lets people enumerate cards by just incrementing the ID. Switched to random public IDs. Planning this upfront would have saved the migration headache.\r\n\r\n## Challenges and Solutions\r\n\r\n### Challenge: QR Code Generation\r\n**Problem**: Generating QR codes requires either a library or external service.\r\n\r\n**Solution**: Used a free QR API for simplicity. Could be swapped with a PHP library (like PHP QR Code) for fully self-contained hosting if API dependency is a concern.\r\n\r\n### Challenge: Public URL Structure\r\n**Problem**: Using sequential database IDs in URLs allows enumeration (guessing other card URLs).\r\n\r\n**Solution**: Generate random public IDs for each card. URLs look like `/card.php?id=abc123xyz` instead of `/card.php?id=1`.\r\n\r\n### Challenge: Image Uploads\r\n**Problem**: File uploads can be a security risk (malicious files, oversized uploads).\r\n\r\n**Solution**: Validate file types (only images), limit file size, use unique filenames, store outside web root when possible.\r\n\r\n### Challenge: vCard Compatibility\r\n**Problem**: Different devices and apps have varying vCard format support.\r\n\r\n**Solution**: Used vCard 3.0 format with standard fields that work across iOS, Android, and desktop applications.\r\n\r\n## Could It Be Better?\r\n\r\nSure. I could add:\r\n- Analytics (track QR scans)\r\n- Custom themes (different colors/layouts)\r\n- Social media links (LinkedIn, Twitter, etc.)\r\n- Custom domains (vanity URLs)\r\n- Team management features\r\n\r\nBut honestly? It does what it needs to do. You make a card, you get a QR code, people scan it. Mission accomplished.\r\n\r\nI'd rather have a simple thing that works than a complex thing that almost works. Feature creep killed more projects than lack of features ever did.\r\n\r\n## Links and Resources\r\n\r\n- **GitHub Repository**: [github.com/tian102/BizQR](https://github.com/tian102/BizQR)\r\n- **Full Documentation**: See README.md in the repository for installation and setup guides\r\n\r\n## Final Thoughts\r\n\r\nI built BizQR because paying a subscription to share my phone number felt absurd. It took a weekend to get working, another week to polish, and now it just... runs.\r\n\r\nNo monthly fees. No vendor lock-in. No \"sorry, we're changing our pricing model\" emails. Just a simple app that does one thing well: let you create and share digital business cards that you actually own.\r\n\r\nIs it fancy? No. Does it use the latest framework? Nope. Does it solve a real problem without unnecessary complexity? Absolutely.\r\n\r\nIf you've ever felt weird about paying monthly just to host your contact info, or if the idea of your QR codes depending on some startup's viability makes you nervous, this might be what you're looking for.\r\n\r\nClone it, host it yourself, and never think about it again. That's the whole point.\r\n\r\n---\r\n\r\n**Tech Stack**: PHP • MySQL • Bootstrap • JavaScript • QR Codes\r\n\r\n**Development Time**: ~2 weeks (mostly polish)\r\n\r\n**Lines of Code**: ~2,500\r\n\r\n*Built it because subscriptions for contact info felt wrong.*\r\n",
    "assetsPath": "content/projects/posts/1-bizqr-digital-cards/assets/",
    "projectPath": "content/projects/posts/1-bizqr-digital-cards/"
  }
]